<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EBSDpython: pythonEBSD/ebsd_Orientation.doxy File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td>
   <div id="projectname"> <!--EBSDpython--> <center> EBSDpython code </center>
    <!-- Version: 1--> 
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_32cce02d098f3570fce83b16a62e12ff.html">pythonEBSD</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ebsd_Orientation.doxy File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tutorials for <a class="el" href="namespaceebsd__Orientation.html">ebsd_Orientation</a>. </p>
<h1><a class="anchor" id="overview_sec"></a>
Overview</h1>
<p>Orientation class: An orientation is combination of material symmetry (e.g. cubic) and specific rotation (e.g. rotated by 45 degrees)</p>
<h1><a class="anchor" id="tutorialsOrientation"></a>
Tutorials</h1>
<h2><a class="anchor" id="exampleColors"></a>
Example: check colors of certain orientations. Answers are given in RGB scale.</h2>
<p>Three examples are investigated:</p><ul>
<li>[100] = red: 1,0,0</li>
<li>[110] = green: 0,1,0 (rotation by 45deg arount Phi)</li>
<li>[111] = blue: 0,0,1 Each example creates an angle from 3 float values, creates an orientation and rounds the color to improve reabability. <pre class="fragment">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from ebsd_Orientation import Orientation
&gt;&gt;&gt; angle = np.radians([0,0,0])
&gt;&gt;&gt; o = Orientation(Eulers=angle, symmetry="cubic")
&gt;&gt;&gt; np.round(o.IPFcolor( [0,0,1] ),3)
array([1., 0., 0.])
&gt;&gt;&gt; angle = np.radians([0,45,0])
&gt;&gt;&gt; o = Orientation(Eulers=angle, symmetry="cubic")
&gt;&gt;&gt; np.round(o.IPFcolor( [0,0,1] ),3)
array([0., 1., 0.])
&gt;&gt;&gt; angle = np.radians([0,55,45])
&gt;&gt;&gt; o = Orientation(Eulers=angle, symmetry="cubic")
&gt;&gt;&gt; np.round(o.IPFcolor( [0,0,1] ),3)
array([0.  , 0.09, 1.  ])</pre></li>
</ul>
<h2><a class="anchor" id="exampleColorsb"></a>
Example: [111] direction is difficult to ad-hoc define by angles. Use vectors to calculate</h2>
<p>and verify </p><div class="image">
<img src="ebsd_Orientation1.png" alt="ebsd_Orientation1.png"/>
</div>
 <pre class="fragment">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; hkl = np.array([1,1,1], dtype=np.float)
&gt;&gt;&gt; uvw1 = np.array([1,-1,0], dtype=np.float)
&gt;&gt;&gt; np.dot(hkl,uvw1)
0.0
&gt;&gt;&gt; hkl /= np.linalg.norm(hkl)
&gt;&gt;&gt; uvw1 /= np.linalg.norm(uvw1)
&gt;&gt;&gt; uvw2 = np.cross(hkl,uvw1)
&gt;&gt;&gt; rotM = np.vstack( (uvw1,uvw2,hkl) )
&gt;&gt;&gt; rotM
array([[ 0.70710678, -0.70710678,  0.        ],
       [ 0.40824829,  0.40824829, -0.81649658],
       [ 0.57735027,  0.57735027,  0.57735027]])
&gt;&gt;&gt; o = Orientation(matrix=rotM, symmetry='cubic')
&gt;&gt;&gt; o.plot()
</pre> <div class="image">
<img src="ebsd_Orientation_1.png" alt="ebsd_Orientation_1.png" width="40%"/>
</div>
 <pre class="fragment">&gt;&gt;&gt; o.plot([1,0,0])
</pre> <div class="image">
<img src="ebsd_Orientation_2.png" alt="ebsd_Orientation_2.png" width="40%"/>
</div>
 <pre class="fragment">&gt;&gt;&gt; o.asEulers(degrees=True)
array([ 0.        , 54.73561032, 45.        ])
&gt;&gt;&gt; np.round(o.IPFcolor( [0,0,1] ),3)                  #should be blue
array([0., 0., 1.])</pre><h2><a class="anchor" id="exampleOrientation1b"></a>
Compare to OIM Software</h2>
<p>OIM software shows the 2D projection with the RD upward. Note, many textbooks have the RD downward. ND is always pointing out of the plane; TD changes depending on RD </p><pre class="fragment">&gt;&gt;&gt; o = Orientation(Eulers=np.radians([0,10,10]), symmetry="cubic")
&gt;&gt;&gt; o.plot( )
</pre> <div class="image">
<img src="ebsd_Orientation_3.png" alt="ebsd_Orientation_3.png" width="40%"/>
</div>
 <pre class="fragment">&gt;&gt;&gt; o.plot(plot2D='up-left')
</pre> <div class="image">
<img src="ebsd_Orientation_4.png" alt="ebsd_Orientation_4.png" width="40%"/>
</div>
 <pre class="fragment">&gt;&gt;&gt; o.plot(poles=[1,0,0], plot2D='up-left', scale=1.5)
</pre> <div class="image">
<img src="ebsd_Orientation_5.png" alt="ebsd_Orientation_5.png" width="40%"/>
</div>
 <pre class="fragment">&gt;&gt;&gt; o.plot(poles=[1,1,1])
</pre> <div class="image">
<img src="ebsd_Orientation_6.png" alt="ebsd_Orientation_6.png" width="40%"/>
</div>
 <pre class="fragment">&gt;&gt;&gt; o.toScreen(equivalent=False)
Euler angles: [ 0. 10. 10.]
HKL [ 1  5 32]
UVW [ 5 -1  0]</pre><p> The HKL and UVW vectors are rounded to integer, hence rough values. They are convenient but not precise.</p>
<h2><a class="anchor" id="exampleOrientation3"></a>
Example: loop through all equivalent directions and calculate the directions</h2>
<pre class="fragment">&gt;&gt;&gt; o = Orientation(Eulers=np.radians([0,45,0]), symmetry="cubic")
&gt;&gt;&gt; oHelp = Orientation(Eulers=np.array([0.,0.,0.]), symmetry="cubic")   #find equivalent directions
&gt;&gt;&gt; for q in oHelp.symmetry.equivalentQuaternions(oHelp.quaternion):
...   axis      = q.conjugated()*np.array([1,0,0])
...   direction = o.inversePole( axis, SST=False)[0]
...   print(axis, direction)
[1. 0. 0.] [1. 0. 0.]
[1. 0. 0.] [1. 0. 0.]
[-1.  0.  0.] [-1.  0.  0.]
[-1.  0.  0.] [-1.  0.  0.]
[-1.  0.  0.] [-1.  0.  0.]
[-1.  0.  0.] [-1.  0.  0.]
[0. 0. 1.] [0.         0.70710678 0.70710678]
[ 0.  0. -1.] [ 0.         -0.70710678 -0.70710678]
[ 0. -1.  0.] [ 0.         -0.70710678  0.70710678]
[0. 1. 0.] [ 0.          0.70710678 -0.70710678]
[0. 0. 1.] [0.         0.70710678 0.70710678]
[0. 1. 0.] [ 0.          0.70710678 -0.70710678]
[ 0.  0. -1.] [ 0.         -0.70710678 -0.70710678]
[0. 0. 1.] [0.         0.70710678 0.70710678]
[ 0.  0. -1.] [ 0.         -0.70710678 -0.70710678]
[ 0. -1.  0.] [ 0.         -0.70710678  0.70710678]
[0. 1. 0.] [ 0.          0.70710678 -0.70710678]
[ 0. -1.  0.] [ 0.         -0.70710678  0.70710678]
[0. 1. 0.] [ 0.          0.70710678 -0.70710678]
[ 0. -1.  0.] [ 0.         -0.70710678  0.70710678]
[ 0.  0. -1.] [ 0.         -0.70710678 -0.70710678]
[0. 0. 1.] [0.         0.70710678 0.70710678]
[1. 0. 0.] [1. 0. 0.]
[1. 0. 0.] [1. 0. 0.]</pre><h2><a class="anchor" id="exampleOrientation4"></a>
Example: calculate average orientation</h2>
<pre class="fragment">&gt;&gt;&gt; a = Orientation(Eulers=np.radians([0,45,0]), symmetry='cubic')
&gt;&gt;&gt; b = Orientation(Eulers=np.radians([0,0,0]), symmetry='cubic')
&gt;&gt;&gt; avg = Orientation.average([a,b,b])                       #take orientation b twice
&gt;&gt;&gt; print("Rotation angles",avg.asEulers(degrees=True))
Rotation angles [ 0.        14.6388066  0.       ]</pre><h1><a class="anchor" id="ebsd_Orientation_Code"></a>
Python source code documentation</h1>
<p><a class="el" href="classebsd__Orientation_1_1Orientation.html">ebsd_Orientation.Orientation</a> material symmetry + rotation of a material point </p>
</div></div><!-- contents -->

<hr class="footer"/><address class="footer"><small>
Copyright by Steffen Brinckmann
<!--Generated on Wed Jan 2 2019 22:29:03 for EBSDpython by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13 -->
</small></address>
</body>
</html>
